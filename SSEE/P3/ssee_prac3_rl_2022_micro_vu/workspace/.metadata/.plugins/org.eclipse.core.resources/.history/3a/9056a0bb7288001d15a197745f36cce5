/*
 * Copyright (c) 2009-2012 Xilinx, Inc.  All rights reserved.
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "platform.h"
#include "xparameters.h"
#include "xiomodule.h"

// Variable para inicializar la E/S. Se pone global
// para que puedan usarla los manejadores de interrupciones
XIOModule iomodule;


// Manejador de Interrupción para el FIT1.
// Habrá que conmutar el led de parpadeo cada 0,5 segundos,
// enviando su nuevo valor por el GPO3 cuando haya que cambiarlo.
// Para ello avisaremos al bucle principal de este evento y en él se tratará.
// -------------------------
// A RELLENAR POR EL ALUMNO
// -------------------------
u8 intc_fit1 = 0;

void_Manejador_Int_Temporizador1(void* ref)
{
	intc_fit1 = 1;
}

// Manejador de Interrupción Externa.
// Cuando se indique desde el exterior habrá que atender a este evento,
// que nos indicará que los resultados ya están calculados y hay que
// recibirlos y mostrarlos por pantalla posteriormente.
// Para ello avisaremos al bucle principal de este evento y en él se tratará.
// -------------------------
// A RELLENAR POR EL ALUMNO
// -------------------------
u8 contador = 0;
u8 intc_ext = 0;

void Manejador_INTC(void* ref)
{
	intc_ext = 1;
}

int main()
{
		u32 data;
		// Inicializa el micro
		init_platform();


		// Inicializa la E/S para GPI y GPO y el módulo de la UART para obtener la dirección base:
		data = XIOModule_Initialize(&iomodule, XPAR_IOMODULE_0_DEVICE_ID);
		data = XIOModule_Start(&iomodule);
		data = XIOModule_CfgInitialize(&iomodule, NULL, 1);


		// Inicializaciones para las interrupciones
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------


		// Bucle para envío de pulsaciones "ficticias" para la simulación completa del circuito
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------


		// Fin de la simulación.
		// Pasamos a operación normal para el resto del programa.
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------


		// Esta línea hace que el cursor se vaya arriba a la izquierda y se borre la pantalla
		// xil_printf("\033[H\033[J");


		// Imprime unos mensajes de instrucciones de manejo
		xil_printf("\n\rPrograma de multiplicación de números complejos\n\r");
		xil_printf("Teclee 4 datos entre 0.0 y 9.9. Tras cada dato pulse 'A'\n\r");
		xil_printf ("\t"); // Orden al Remote Lab de enviar todos los printf anteriores a la consola.

		while(1)
		{
		// Bucle para leer del teclado; comprobará si ocurre alguno de estos eventos:
		//
		// A) El usuario pulse alguna tecla de las que reconocemos para este programa (números del 0 al 9 o la
		// tecla 'A'). Si se pulsa una tecla no reconocida se vuelve a leer.
		//
		// B) Se active la interrupción Externa INTC.
		//
		// C) Se active la interrupción del Temporizador FIT1.
		// ----------------------------------------------------------
		// Tratamiento del caso A) El usuario ha pulsado alguna tecla.
		// ----------------------------------------------------------
		//
		// Hay que comprobar qué tecla es y enviarla hacia el módulo de cálculo.
		//
		// Comprobamos cuál es el carácter que ha pulsado el usuario comparándolo con los códigos ASCII
		// que nos interesan, que serán de la tecla "0" a la tecla "9", así como la "A".
		// Para cada pulsación habrá que generar un código de "cod_tecla_micro(3:0)" oportuno para enviarlo
		// hacia la FPGA posteriormente y una señal de sincronismo de “tecla_pulsada_micro”.
		// También habrá que imprimir por pantalla el carácter tecleado por el usuario para que lo vea,
		// siempre que sea un número, y el punto decimal cuando corresponda (en la 2ª cifra a introducir).
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Enviamos a la FPGA por el puerto GPO1 el valor del código que corresponde,
		// para que llegue a la FPGA "cod_tecla_micro(3:0)"
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Simulamos un pulso de "tecla_pulsada_micro" escribiendo un "1"
		// y posteriormente un "0" en el GPO2:
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Volvemos al principio del bucle


		// -------------------------------------------------------------------
		// Tratamiento del caso B) Se ha activado la interrupción Externa INTC.
		// -------------------------------------------------------------------
		//
		// Hay que leer los resultados y sus signos, y escribirlos por pantalla.
		//
		// Leemos los valores de Result_BCD_Real(15:0) y Result_BCD_Imag(15:0) de GPI1.
		// Leemos los valores de Signo_Real y Signo_Imag de GPI2.
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Hacemos las operaciones lógicas necesarias a nivel de bit para separar los datos
		// del puerto GPI1 y los signos del puerto GPI2:
		// GPI1 --> bits(31:16) --> Result_BCD_Real(15:0) (serán decenas, unidades, décimas y centésimas en BCD)
		// GPI1 --> bits(15:0) --> Result_BCD_Imag(15:0) (serán decenas, unidades, décimas y centésimas en BCD)
		// GPI2 --> bit (0) --> Signo_Imag
		// GPI2 --> bit (1) --> Signo_Real
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Imprimimos por pantalla los datos leídos haciendo los "xil_printf" necesarios.
		// Tener en cuenta que hay que imprimir el signo, las cifras BCD y la coma decimal
		// en los sitios oportunos.
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Esperamos a que el usuario pulse la letra "C" para volver al inicio
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Volvemos al principio del bucle


		// -------------------------------------------------------------------
		// Tratamiento del caso C) Se ha activado la interrupción del Temporizador FIT1.
		// -------------------------------------------------------------------
		//
		// Hay que comprobar si han pasado 0,5 segundos desde la última conmutación del led.
		// En caso negativo no se hace nada y se vuelve al principio del bucle.
		// En caso positivo, se cambia de valor el led y se envía por GPO3.
		// -------------------------
		// A RELLENAR POR EL ALUMNO
		// -------------------------
		//
		// Volvemos al principio del bucle
}
cleanup_platform();
return 0;
}

// source ipcore_dir/microblaze_mcs_setup.tcl
// microblaze_mcs_data2mem workspace/hello_world/debug/hello_world.elf
